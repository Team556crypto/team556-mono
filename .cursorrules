# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Lessons

## Cursor learned

- When working with React Navigation tabs, custom tabBar components need to use the properties available in BottomTabBarProps (avoid using non-existent properties like tabBarTestID)
- When using react-native-reanimated with TypeScript, the component return may have type issues with ReactNode. In this case, using fragment syntax (<></>) instead of <View /> can help avoid certain TypeScript errors.
- For deeper React Native TypeScript issues with ReactNode children inside View components, wrapping children in a React.Fragment before passing to the View can resolve type conflicts between React's ReactNode and React Native's expected type.

# Scratchpad

## Task: Analyze Repository and Address Technical Questions

The task is to analyze the repository structure and address the following questions one by one:

1. Observability tools and monitoring practices in Go and Express servers
2. CI/CD implementation across the monorepo
3. Monorepo management (Nx, Turborepo, or custom solution)
4. Database strategy for transactional and user data
5. State handling across wallet and POS systems
6. Security measures in the Express-based token operation server

### Steps:

[X] Examine repository structure - Confirmed Turborepo monorepo setup
[X] Explore apps/ and packages/ directories to understand project organization
[X] Identify Go and Express server implementations
[X] Analyze CI/CD configuration files
[X] Review database configuration and implementation
[X] Examine observability and monitoring tools
[X] Check state management across wallet and POS systems
[X] Review security measures in token operation server
[X] Formulate answers to each question based on findings

### Findings:

1. **Repository Structure:**

   - Monorepo using Turborepo for build orchestration
   - Apps directory contains:
     - main-api: Go server using Fiber framework
     - solana-api: Express.js server for Solana blockchain interactions
     - wallet: Mobile app (React Native/Expo based)
     - pos: Point of Sale app (React Native/Expo)
     - prototype: Development/testing app
   - Packages directory contains:
     - ui: Shared UI components
     - eslint-config: Shared ESLint configuration
     - typescript-config: Shared TypeScript configuration

2. **Server Implementations:**

   - Main API: Go server using Fiber framework (minimal implementation currently)
   - Solana API: Express.js server with:
     - Basic security with helmet middleware
     - CORS support
     - Route structure for wallet operations
     - Health check endpoints

3. **Monorepo Management:**

   - Using Turborepo for build orchestration and dependency management
   - Configured in turbo.json with tasks for build, lint, type checking
   - Workspaces defined in package.json for apps/_ and packages/_

4. **No visible CI/CD configuration:**

   - No .github/workflows, gitlab-ci.yml, or other CI config files found
   - No dedicated deployment scripts visible

5. **Observability and Monitoring:**

   - No dedicated observability tools implemented in either server
   - Basic console logging in the Express server
   - No structured logging, metrics collection, or tracing observed
   - No integration with external monitoring platforms (Datadog, New Relic, etc.)
   - No health check API endpoints beyond basic "healthy" status response

6. **Database Strategy:**

   - No database configuration or connection code found in the codebase
   - No ORM libraries (Prisma, Sequelize, TypeORM, Mongoose) detected
   - No database migration tools or schemas observed
   - Both servers appear to be stateless API layers with no persistent storage currently implemented

7. **State Management:**

   - React Context API used in both wallet and POS apps for:
     - Drawer state (showing/hiding UI drawer components)
     - Step form state (multi-step form navigation)
   - React useState hooks used for local component state
   - No evidence of Zustand implementation despite project rules mentioning it
   - No Redux, Recoil, Jotai, or other state management libraries detected

8. **Security Measures:**
   - Minimal security implementation in the Express server:
     - Helmet middleware for standard HTTP headers
     - CORS support
   - No authentication/authorization mechanisms implemented
   - No rate limiting observed
   - No input validation beyond Express's basic parsing
   - No token validation or security measures for wallet operations

### Answers to Questions:

1. **Observability tools and monitoring practices:**
   Currently minimal observability implementation. Both servers have basic health check endpoints but lack structured logging, metrics collection, tracing, or integration with monitoring platforms.

2. **CI/CD across the monorepo:**
   No formal CI/CD implementation evident in the codebase. No configuration files for GitHub Actions, GitLab CI, Jenkins, or other CI/CD platforms were found.

3. **Monorepo management:**
   Using Turborepo for build orchestration and dependency management. The configuration in turbo.json defines tasks for build, lint, and type checking with appropriate dependencies between packages.

4. **Database strategy:**
   No database implementation currently in the codebase. There are no database connection configurations, ORM usage, or schema definitions visible in either server.

5. **State handling across wallet and POS systems:**
   Both applications use React Context API for global state management with useState hooks for local component state. Despite project rules mentioning Zustand, there's no implementation of it yet.

6. **Security measures in the Express server:**
   Basic security with Helmet middleware and CORS support, but lacks authentication, rate limiting, proper request validation, and token-specific security measures.

## Task: Implement a Bottom Drawer Component

The task is to implement a bottom drawer component that slides up from the bottom, similar to the native iOS drawer. This drawer should support any content and have a top grab handle that can be dragged down to dismiss the drawer.

### Steps:

[X] Check existing app structure to understand the application architecture
[X] Create a reusable Drawer component in the shared UI package
[X] Implement slide-up animation with react-native-reanimated
[X] Add gesture handling for the draggable grab handle
[X] Support different drawer heights/sizes
[X] Create a simple example to demonstrate the drawer in the prototype app
[X] Export the component through the shared UI package index
[X] Fix TypeScript errors with ReactNode handling

### Implementation:

1. First checked the app structure and available libraries
   - Found react-native-reanimated and react-native-gesture-handler already installed
   - Identified the shared UI package in packages/ui/src
   - App uses dark theme colors defined in constants/Colors.ts
   - App has a responsive design pattern
2. Created the Drawer component with the following features:
   - Slide-up animation with spring physics for natural feel
   - Configurable drawer sizes (small, medium, large, full)
   - Gesture detection for dragging the drawer down to dismiss
   - Dark theme styling consistent with the app
   - Backdrop overlay with tap-to-dismiss functionality
   - Customizable styles for container, handle, and content
3. Added the component to the shared UI package
   - Created Drawer.tsx in packages/ui/src
   - Updated packages/ui/index.ts to export the component
4. Added a simple example in the prototype app
   - Added a button to open the drawer
   - Implemented demonstration content within the drawer
   - Added a close button for accessibility
5. Fixed TypeScript errors with ReactNode handling
   - Wrapped children in a React.Fragment before passing to View component
   - Used Fragment instead of empty tags (<></>) for better type compatibility
   - Changed Animated.View to regular View for content container to avoid type conflicts

### Findings:

- The react-native-reanimated and react-native-gesture-handler libraries provide powerful tools for creating smooth, native-like animations and gestures
- The shared UI package structure makes it easy to create reusable components across the app
- The drawer component follows iOS-like behavior with the grab handle and slide-up animation
- The component is fully responsive and adapts to different screen sizes
- There were some TypeScript challenges with ReactNode typing that were addressed by using React.Fragment
- Using a Fragment wrapper for children content helps to maintain type safety when dealing with React Native views
